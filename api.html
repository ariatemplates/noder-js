<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>noderJS - API</title>
<meta charset="utf-8">
<link href="images/favicon.ico" type="image/ico"
	rel="shortcut icon">
<link rel="stylesheet" href="css/all.css" type="text/css">
<link rel="stylesheet" href="css/noder.css" type="text/css">
<link rel="stylesheet" href="css/snippets/style.css" type="text/css">
<link rel="stylesheet" href="css/snippets/highlight_skin.css" type="text/css">
<!-- font-awesome -->
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<!--[if IE 7]>
    <link rel="stylesheet" href="css/versionselect.css" type="text/css"><![endif]-->
<link rel="stylesheet" href="css/documentation.css" type="text/css">
<!--[if lt IE 9]>
    <script type="text/javascript" src="js/iemap.js"></script>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript" charset="utf-8"></script>
    <style>.ie-hidden {display:none;}</style><![endif]-->
<!--[if lt IE 8]>
    <link href="css/ie7.css" rel="stylesheet" type="text/css"><![endif]-->
</head>
<body class="documentation">
	<header id="header">
    <div class="logo">
      <h5>
        <a href="./index.html"><img alt="noderJS"
          src="images/logo-nav.png"></a>
      </h5>
    </div>
    <nav>
      <a class="getstarted " href="./getstarted.html">Get started</a>
      <a class="configuration " href="./configuration.html">Configuration options</a>
      <a class="api selected" href="./api.html">API</a>
      <a class="build " href="./build.html">Contribute</a>
      <a class="packaging " href="./packaging.html">Packaging</a>
    </nav>
  </header>
	<div class="content-wrapper">
		<section class="content">
			<div class="wrapper">
				<div class="columns main-page one">
					<article class="column"><h1 id="noderjs-api">noderJS API</h1>
<p>This page details the public API exposed by noderJS.</p>
<h2 id="module-variables">Module variables</h2>
<p>Inside a module loaded with noderJS, the following variables are automatically available.
They are compatible with the corresponding variables available from a module loaded
in <a href="http://nodejs.org/api/globals.html">Node.js</a>:</p>
<ul>
<li><a href="http://nodejs.org/api/globals.html#globals_global">global</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require_resolve">require.resolve</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require_cache">require.cache</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_require">require.main</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_exports">exports and module.exports</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_filename">module.filename</a> and <a href="http://nodejs.org/api/modules.html#modules_module_id">module.id</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_loaded">module.loaded</a></li>
<li><a href="http://nodejs.org/api/modules.html#modules_module_require_id">module.require</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_filename">__filename</a></li>
<li><a href="http://nodejs.org/api/globals.html#globals_dirname">__dirname</a></li>
</ul>
<h2 id="noder-global-variable">noder global variable</h2>
<p>noderJS creates a global variable called <code>noder</code> (its name is <a href="configuration.html">configurable</a>).
This variable corresponds to the root module that is automatically created by noderJS.
All the properties usually available on the <code>module</code> variable in a module (and listed in the previous section)
are also available on the <code>noder</code> global variable. Moreover, the following shortcuts are also available for
convenience (most of them are documented later in this page):</p>
<ul>
<li><code>noder.asyncRequire = noder.require(&quot;noder-js/asyncRequire&quot;)</code></li>
<li><code>noder.define = noder.require(&quot;noder-js/currentContext&quot;).define</code></li>
<li><code>noder.execute = noder.require(&quot;noder-js/currentContext&quot;).jsModuleExecute</code></li>
<li><code>noder.createContext = noder.require(&quot;noder-js/context&quot;).createContext</code></li>
<li><code>noder.updatePackagesMap</code>: the map provided as a parameter will be recursively merged with the existing one (it is normally provided in the <a href="configuration.html">configuration</a>). This method can be useful when you want noder to be able to load modules from packages. For more information on packaging, see <a href="packaging.html">here</a>.</li>
</ul>
<p>The <code>noder</code> global variable is especially intended to be used from any JavaScript code in the page that is not
loaded through noderJS (and thus does not have access to its own <code>module</code> and <code>require</code> variables). Unless there
is a good reason, it should not be used inside a module loaded through noderJS, as, for better compatibility with
CommonJS standards, it is better to use the local <code>module</code> and <code>require</code> variables.</p>
<p>Note that the <code>noder</code> global variable is especially useful for debugging: you can inspect the noderJS cache
and access all modules through <code>noder.require.cache</code>.</p>
<h2 id="asynchronous-module-loading">Asynchronous module loading</h2>
<h4 id="usage">Usage</h4>
<p>In addition to the basic synchronous standard version of require (which is equivalent to a static dependency), noderJS
provides a promises-based <code>asyncRequire</code> method to load a module asynchronously:</p>
<p><strong>asyncRequire (modulePath1, modulePath2...) : Promise</strong></p>
<p><code>asyncRequire</code> accepts any number of module paths as parameters and returns a promise giving access to the array of
the <code>exports</code> objects of all requested modules.</p>
<p>It can be used in the following way:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>);

<span class="comment">// asyncRequire preloads and executes the modules given as parameters and returns a promise.</span>
<span class="comment">// As the promise result is an array, it is possible to use "spread" to get each array item</span>
<span class="comment">// as a different argument of the given handler function:</span>
asyncRequire(<span class="string">"myFirstModule"</span>, <span class="string">"mySecondModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myFirstModule, mySecondModule)</span>{</span>
    <span class="comment">// Do something with myFirstModule and mySecondModule</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
    <span class="comment">// Do something in case of failure</span>
});</code></pre></div>
<h4 id="relative-paths">Relative paths</h4>
<p>If you want to use relative paths in <code>asyncRequire</code> (i.e. paths which are relative to the current module, in the same way
as it is possible with the synchronous <code>require</code>), you can either convert them to absolute paths with <code>require.resolve</code>
or you can create a local version of the <code>asyncRequire</code> method, as shown in the following two equivalent examples:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>);

<span class="comment">// Use require.resolve to convert the relative path into an absolute path:</span>
asyncRequire(<span class="built_in">require</span>.resolve(<span class="string">"./myRelativeModule"</span>)).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myRelativeModule)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<div class='snippet'><pre><code class="lang-js"><span class="comment">// Use the create method to create a local version of the asyncRequire method which accepts relative paths:</span>
<span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">'noder-js/asyncRequire'</span>).create(module);

<span class="comment">// Then relative paths can be used directly:</span>
asyncRequire(<span class="string">"./myRelativeModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myRelativeModule)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<h4 id="shortcut">Shortcut</h4>
<p>For convenience, the <code>asyncRequire</code> method is also available on the <code>noder</code> global variable, so that it is easy to load
some modules asynchronously, even from code which was not loaded through noderJS:</p>
<div class='snippet'><pre><code class="lang-js">noder.asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span>{</span> <span class="comment">/* ... */</span> }, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span> <span class="comment">/* ... */</span> });</code></pre></div>
<h2 id="loader-plugins">Loader plugins</h2>
<p>Before a module can be executed in noderJS, it has to be preloaded. The preload process consists in downloading the
module file, parsing it to detect its static dependencies, and preloading those dependencies. The preload process is usually
asynchronous, as it usually involves one or more XHR requests (which, by default, are configured to be asynchronous).</p>
<p>noderJS provides the ability to add custom actions to the preload process, by implementing a loader plugin.
This is especially useful to preload additional dependencies which cannot be automatically detected because they are
not static. These include, for example, language-dependent resources or browser-dependent code.</p>
<p>For example, let&#39;s consider our <code>sample.js</code> module which depends on a language-dependent resource.
The code could look like the following example:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> language = <span class="built_in">require</span>(<span class="string">"resourcesManager"</span>).language;
<span class="keyword">var</span> myResources = <span class="built_in">require</span>(<span class="string">"./myRes_"</span>+language);
<span class="comment">// ...</span></code></pre></div>
<p>When parsing this file, noderJS will find <code>resourcesManager</code> as a static dependency, but will be unable know the other file to preload
as it depends on the <code>language</code> variable, whose value is unknown at the time the file is parsed (as it is not executed yet).
As a result, when later executing this file, the second require will probably fail because the dependency will not have been preloaded
and it will most likely not be possible to preload it synchronously (if XHR requests are configured to be asynchronous).</p>
<p>To solve this kind of issues, or to execute any other custom actions asynchronously, support for loader plugins was implemented.
The parser detects the pattern <code>require(&quot;loaderPluginPath/$loaderPluginName&quot;).methodName(arg1, arg2...)</code> in the file to be preloaded,
and executes the loader plugin module at preloading time. It calls the <code>$preload</code> method on the <code>methodName</code> property of the object
exported by the loader plugin and executes it with the parsed arguments (which must be either string literals or the special <code>__dirname</code>,
<code>__filename</code> and <code>module</code> variable, or <code>null</code>). The <code>$preload</code> method can return a promise. If it is the case, the preload process will
wait for the promise to be fulfilled before marking the module as preloaded.</p>
<p>Now our <code>sample.js</code> module depending on a language-dependent resource can be re-written in the following way:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> myResources = <span class="built_in">require</span>(<span class="string">"$resourcesLoader"</span>).getResource(__dirname, <span class="string">"./myRes"</span>);
<span class="comment">// ...</span></code></pre></div>
<p>The loader plugin, called <code>$resourcesLoader.js</code> could look like this:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);
<span class="keyword">var</span> language = <span class="built_in">require</span>(<span class="string">"resourcesManager"</span>).language;
exports.getResource = <span class="function"><span class="keyword">function</span><span class="params">(directory, resource)</span> {</span>
   <span class="comment">// this method is executed when sample.js is executed</span>
   <span class="comment">// it is synchronous</span>
   <span class="keyword">return</span> <span class="built_in">require</span>(directory + <span class="string">"/"</span> + resource);
};
exports.getResource.$preload = <span class="function"><span class="keyword">function</span><span class="params">(directory, resource)</span> {</span>
   <span class="comment">// this method is automatically executed when sample.js is preloaded</span>
   <span class="comment">// it can be asynchronous by returning a promise</span>
   <span class="keyword">return</span> asyncRequire(directory + <span class="string">"/"</span> + resource);
};</code></pre></div>
<h2 id="promises-library">Promises library</h2>
<p><a href="http://promisesaplus.com/">
<img src="http://promisesaplus.com/assets/logo-small.png" alt="Promises/A+ logo" title="Promises/A+ 1.1.1 compliant" align="right"
 style="margin-left:10px;" />
</a></p>
<p>noderJS heavily relies on promises. It includes a lightweight promise library which is compliant with the
<a href="http://promisesaplus.com">Promises/A+ specifications</a> version 1.1.1.</p>
<p>The integrated promise library can be accessed with:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);</code></pre></div>
<h3 id="promise-constructor">Promise constructor</h3>
<p><strong>new Promise (factoryFunction : function(resolve, reject)) : Promise</strong></p>
<p>Creates a new promise. The given <code>factoryFunction</code> gets a reference to the <code>resolve</code> and <code>reject</code> methods which
allow to resolve or reject the promise. If the <code>factoryFunction</code> raises an exception before calling <code>resolve</code>
or <code>reject</code>, the promise is rejected with the exception as the reason.</p>
<p>Here is a sample implementing a promise-based version of <code>setTimeout</code>:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> setTimeoutWithPromise = <span class="function"><span class="keyword">function</span> <span class="params">(delay)</span> {</span>
   <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> {</span>
      setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
         resolve(<span class="number">7</span>);
      }, delay);
   });
};

console.log(<span class="string">"Before calling setTimeoutWithPromise"</span>);
setTimeoutWithPromise(<span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> {</span>
   console.log(<span class="string">"In the callback. The result is: "</span> + result)
});
console.log(<span class="string">"After calling setTimeoutWithPromise"</span>);

<span class="comment">// The console should contain:</span>
<span class="comment">// Before calling setTimeoutWithPromise</span>
<span class="comment">// After calling setTimeoutWithPromise</span>
<span class="comment">// In the callback. The result is: 7</span></code></pre></div>
<p>Using the Promise constructor is the recommended way to create a promise. Alternatively, it is also possible
to use the <code>Promise.defer</code> method below.</p>
<h3 id="promise-defer-">Promise.defer()</h3>
<p><strong>Promise.defer () : Defer</strong></p>
<p>Creates a new defer. A defer is an object with 3 properties:</p>
<div class='snippet'><pre><code class="lang-js">{
   promise: promise, <span class="comment">/* Promise instance object (with the 'then' method) */</span>
   resolve: resolve, <span class="comment">/* Function to resolve the promise, with the specified value. */</span>
   reject: reject <span class="comment">/* Function to reject the promise, with the specified reason. */</span>
}</code></pre></div>
<p>Here is a sample re-implementing the <code>setTimeoutWithPromise</code> function from the previous section,
but using <code>Promise.defer()</code> instead of the promise constructor.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> setTimeoutWithPromise = <span class="function"><span class="keyword">function</span> <span class="params">(delay)</span> {</span>
   <span class="keyword">var</span> defer = Promise.defer();
   setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      defer.resolve(<span class="number">7</span>);
   }, delay);
   <span class="keyword">return</span> defer.promise;
};</code></pre></div>
<h3 id="promise-resolve-">Promise.resolve()</h3>
<p><strong>Promise.resolve(valueOrPromise) : Promise</strong></p>
<p>If <code>valueOrPromise</code> is a noder-js promise, <code>Promise.resolve</code> returns it directly.</p>
<p>If <code>valueOrPromise</code> is an object or a function with a <code>thenSync</code> or <code>then</code>  method, it is considered as a promise and
<code>Promise.resolve</code> returns an equivalent noderJS promise.</p>
<p>Otherwise, <code>Promise.resolve</code> returns an already fulfilled promise, whose fulfillment value is <code>valueOrPromise</code>.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

<span class="keyword">var</span> promiseInstance = Promise.resolve(<span class="number">7</span>);
promiseInstance.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> <span class="comment">/* here, value == 7 */</span> });
Promise.resolve(promiseInstance) <span class="comment">// this call returns promiseInstance</span>
Promise.resolve({
   then: <span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
      resolve(<span class="number">7</span>);
   }
}).then(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span> <span class="comment">/* here, value == 7 */</span> });</code></pre></div>
<h3 id="promise-reject-">Promise.reject()</h3>
<p><strong>Promise.reject(reason) : Promise</strong></p>
<p><code>Promise.reject</code> returns a rejected promise with the given reason.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);

Promise.reject(<span class="string">"error"</span>).catch(<span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span> <span class="comment">/* here, reason == "error" */</span> });</code></pre></div>
<h3 id="promise-done">Promise.done</h3>
<p><strong>Promise.done : Promise</strong></p>
<p><code>Promise.done</code> is a reference to an already resolved promise, whose fulfillment value is <code>undefined</code>.</p>
<p>It is defined by:</p>
<div class='snippet'><pre><code class="lang-js">Promise.done = Promise.resolve();</code></pre></div>
<p>It can be used instead of <code>Promise.resolve(undefined)</code> to avoid creating a new promise instance.</p>
<h3 id="promise-all-and-promise-allsettled-">Promise.all() and Promise.allSettled()</h3>
<p><strong>Promise.all (promiseOrValueArray : Array) : Promise</strong></p>
<p><strong>Promise.allSettled (promiseOrValueArray : Array) : Promise</strong></p>
<p><code>Promise.all</code> and <code>Promise.allSettled</code> return a promise that is fulfilled when all the given promises are fulfilled.</p>
<p><code>Promise.all</code> is the fail-fast version of <code>Promise.allSettled</code>:</p>
<ul>
<li>the promise returned by <code>Promise.allSettled</code> is rejected only when all promises are either fulfilled or rejected.</li>
<li>the promise returned by <code>Promise.all</code> is rejected as soon as any promise is rejected, without waiting for other
promises to either be fulfilled or rejected.</li>
</ul>
<p>Apart from that timing difference, <code>Promise.all</code> and <code>Promise.allSettled</code> are otherwise fully equivalent.</p>
<p>Here is an example showing how to use <code>Promise.all</code>:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

Promise.all([<span class="string">"simple value"</span>, asyncRequire(<span class="string">"myModule1"</span>, <span class="string">"myModule2"</span>)]).spread(<span class="function"><span class="keyword">function</span> <span class="params">(simpleValue, myModules)</span> {</span>
   <span class="comment">// here:</span>
   <span class="comment">// simpleValue == "simple value"</span>
   <span class="comment">// myModules is an array containing the exports objects of myModule1 and myModule2</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
   <span class="comment">// this function is called in case there is an error while loading myModule1 or myModule2</span>
});</code></pre></div>
<h3 id="promiseinstance-then-and-its-shortcuts">promiseInstance.then() and its shortcuts</h3>
<p><strong>promiseInstance.then(onFulfilled : function (value), onRejected : function (reason)) : Promise</strong></p>
<p><code>promiseInstance.then</code> adds a fulfillment and a rejection handler to the promise, and returns a new promise
resolving to the return value of the called handler.</p>
<p>If <code>onFulfilled</code> is null (or not a function), and <code>promiseInstance</code> is fulfilled, the returned promise is
fulfilled with the same fulfillment value.</p>
<p>If <code>onRejected</code> is null (or not a function), and <code>promiseInstance</code> is rejected, the returned promise is rejected
with the same reason.</p>
<p>If both <code>onFulfilled</code> and <code>onRejected</code> are null (or not functions), <code>promiseInstance</code> itself is returned.</p>
<p>The following shortcuts for <code>promiseInstance.then</code> are available:</p>
<p><strong>promiseInstance.catch(onRejected : function (reason)) : Promise</strong></p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.catch(onRejected);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(<span class="literal">null</span>, onRejected);</code></pre></div>
<p><strong>promiseInstance.finally(handler : function (value)) : Promise</strong></p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.finally(handler);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(handler, handler);</code></pre></div>
<p><strong>promiseInstance.spread(onFulfilled : function (value1, value2 ...), onRejected : function (reason)) : Promise</strong></p>
<p><code>promiseInstance.spread</code> can be used when the fulfillment value is expected to be an array.</p>
<div class='snippet'><pre><code class="lang-js">promiseInstance.spread(onFulfilled, onRejected);
<span class="comment">// is equivalent to:</span>
promiseInstance.then(<span class="function"><span class="keyword">function</span><span class="params">(array)</span> {</span>
  <span class="comment">// each item of the array is passed as a different argument to onFulfilled:</span>
  <span class="keyword">return</span> onFulfilled.apply(<span class="literal">null</span>, array);
}, onRejected);</code></pre></div>
<p><strong>promiseInstance.done(onFulfilled : function (value), onRejected : function (reason))</strong></p>
<p>The <code>done</code> method is equivalent to <code>then</code> except that it does not return a new promise, and it reports any error by throwing it
asynchronously.
It is often used without any argument to end a promises chain so that any unhandled error in the chain is properly
reported instead of being silently ignored.</p>
<p>For example, with the folling code, if an error occurs when loading <code>myModule</code>, or in the function which uses <code>myModule</code>,
the error is silently ignored:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span> {</span>
  <span class="comment">// do something with myModule</span>
}); <span class="comment">// without .done(), errors in this promises chain are silently ignored</span></code></pre></div>
<p>Adding <code>.done()</code> at the end of the promises chain makes sure any unhandled error happening in the promises chain is properly reported:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncRequire = <span class="built_in">require</span>(<span class="string">"noder-js/asyncRequire"</span>);

asyncRequire(<span class="string">"myModule"</span>).spread(<span class="function"><span class="keyword">function</span> <span class="params">(myModule)</span> {</span>
  <span class="comment">// do something with myModule</span>
}).done(); <span class="comment">// with .done(), errors are properly reported</span></code></pre></div>
<h3 id="promiseinstance-thensync-and-its-shortcuts">promiseInstance.thenSync() and its shortcuts</h3>
<p>Following the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ specifications</a>, the <code>promiseInstance.then</code> method never
calls its handlers synchronously. The same applies to the associated <code>spread</code>, <code>catch</code>, <code>finally</code> and <code>done</code> shortcuts.</p>
<p>However, in some cases, it can be useful to avoid code duplication by handling both the asynchronous and the synchronous cases with
the same code. For example, noderJS itself can be configured to use either synchronous or asynchronous XHR requests and uses the same
code to handle both cases, without adding asynchronism uselessly.</p>
<p>For this to be possible, noderJS provides the <code>thenSync</code>, <code>spreadSync</code>, <code>catchSync</code>, <code>finallySync</code> and <code>doneSync</code> methods which behave
exactly as their <code>then</code>, <code>spread</code>, <code>catch</code>, <code>finally</code> and <code>done</code> counterparts, except that, in case the promise is already fulfilled or
rejected at the time the <code>xSync</code> method is called, the corresponding handler is called synchronously.</p>
<p>Here is an example which shows the difference between <code>then</code> and <code>thenSync:</code></p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> thenValue, thenSyncValue;
<span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> myPromise = Promise.resolve(<span class="number">7</span>);

<span class="comment">// myPromise is already fulfilled</span>
myPromise.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenValue = value; });
myPromise.thenSync(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenSyncValue = value; });
console.log(<span class="string">"thenValue = "</span> + thenValue);
console.log(<span class="string">"thenSyncValue = "</span> + thenSyncValue);

<span class="comment">// The result in the console is:</span>
<span class="comment">// thenValue = undefined</span>
<span class="comment">// thenSyncValue = 7</span></code></pre></div>
<p>Note that the behavior of <code>thenSync</code> only differs from the one of <code>then</code> if it is called on an already fulfilled or rejected promise.
In the following sample, both <code>then</code> and <code>thenSync</code> behave in the same way because the promise is still pending when <code>then</code> and <code>thenSync</code> are called:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> thenValue, thenSyncValue;
<span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
<span class="keyword">var</span> defer = Promise.defer();
<span class="keyword">var</span> myPromise = defer.promise;

<span class="comment">// myPromise is not yet fulfilled</span>
myPromise.then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenValue = value; });
myPromise.thenSync(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span> thenSyncValue = value; });

defer.resolve(<span class="number">7</span>); <span class="comment">// now it is fulfilled, but the handlers will be called asynchronously</span>
console.log(<span class="string">"thenValue = "</span> + thenValue);
console.log(<span class="string">"thenSyncValue = "</span> + thenSyncValue);

<span class="comment">// The result in the console is:</span>
<span class="comment">// thenValue = undefined</span>
<span class="comment">// thenSyncValue = undefined</span></code></pre></div>
<p>Note that <code>thenSync</code> is not (yet?) standard. There was a <a href="https://github.com/promises-aplus/promises-spec/issues/169">request</a> to better integrate
Promises/A+ specifications with synchronous code, but it was unfortunately rejected.</p>
<h3 id="promiseinstance-isfulfilled-and-promiseinstance-isrejected-">promiseInstance.isFulfilled() and promiseInstance.isRejected()</h3>
<p><strong>promiseInstance.isFulfilled() : Boolean</strong></p>
<p>Returns <code>true</code> if <code>promiseInstance</code> is fulfilled, and <code>false</code> otherwise.</p>
<p><strong>promiseInstance.isRejected() : Boolean</strong></p>
<p>Returns <code>true</code> if <code>promiseInstance</code> is rejected, and <code>false</code> otherwise.</p>
<p>If both <code>promiseInstance.isFulfilled()</code> and <code>promiseInstance.isRejected()</code> return <code>false</code>, the promise is still pending.
<code>promiseInstance.isFulfilled()</code> and <code>promiseInstance.isRejected()</code> never both return <code>true</code> for the same promise instance.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
Promise.resolve(<span class="number">7</span>).isFulfilled() <span class="comment">// returns true</span>
Promise.resolve(<span class="number">7</span>).isRejected() <span class="comment">// returns false</span>
Promise.reject(<span class="number">7</span>).isFulfilled() <span class="comment">// returns false</span>
Promise.reject(<span class="number">7</span>).isRejected() <span class="comment">// returns true</span>
Promise.defer().promise.isFulfilled() <span class="comment">// returns false</span>
Promise.defer().promise.isRejected() <span class="comment">// returns false</span></code></pre></div>
<h3 id="promiseinstance-result-">promiseInstance.result()</h3>
<p><strong>promiseInstance.result()</strong></p>
<p>If <code>promiseInstance</code> is fulfilled, <code>promiseInstance.result()</code> returns the fulfillment value.</p>
<p>If <code>promiseInstance</code> is rejected, <code>promiseInstance.result()</code> returns the rejection reason.</p>
<p>Otherwise (i.e. <code>promiseInstance</code> is still pending), <code>promiseInstance.result()</code> returns <code>undefined</code>.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"noder-js/promise"</span>);
Promise.resolve(<span class="number">7</span>).result() <span class="comment">// returns 7</span>
Promise.reject(<span class="number">7</span>).result() <span class="comment">// returns 7</span>
Promise.defer().promise.result() <span class="comment">// returns undefined</span></code></pre></div>
<h2 id="request-utility">Request utility</h2>
<p>noderJS contains a small promises-based utility to make network requests:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">"noder-js/request"</span>);</code></pre></div>
<p>It is a simple wrapper around <a href="http://www.w3.org/TR/XMLHttpRequest">XMLHttpRequest</a> that hides some of the
differences between browsers and makes it easy to request files.</p>
<p><strong>request (url: String, options: Object) : Promise</strong></p>
<p>This method sends a request to the server for the specified url and returns a promise.</p>
<p>The options object is optional. Here is the list of accepted options:</p>
<div class='snippet'><pre><code class="lang-js">options : {
   headers : {
      <span class="comment">// Headers to be included in the request, for example:</span>
      <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>
   },
   data : <span class="string">"My Request is..."</span>, <span class="comment">// String - Body of the request</span>
   sync : <span class="literal">false</span>, <span class="comment">// Boolean - Specifies if the request is synchronous or not (default: false)</span>
   method : <span class="string">"POST"</span> <span class="comment">// String - Type of request (default: "GET")</span>
}</code></pre></div>
<p>Here is an example, which posts a json object to the server, and parses the response as json:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">"noder-js/request"</span>);

request(<span class="string">"/api/"</span>, {
   method: <span class="string">"POST"</span>,
   headers: {
     <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>
   },
   data: <span class="built_in">JSON</span>.stringify(myJsonObjectToSend)
}).then(<span class="function"><span class="keyword">function</span> <span class="params">(xhr)</span> {</span>
   <span class="comment">// Success callback</span>
   <span class="comment">// Parses the response as JSON:</span>
   <span class="keyword">var</span> responseText = xhr.responseText;
   <span class="keyword">var</span> responseJson = <span class="built_in">JSON</span>.parse(responseText);
   <span class="comment">// ...</span>
}).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> {</span>
   <span class="comment">// error callback handling cases when either the request fails or parsing the response JSON fails</span>
   <span class="comment">// ...</span>
});</code></pre></div>
<h2 id="context">Context</h2>
<p>A noderJS context is automatically created when noderJS is loaded. noderJS also provides an API to create new contexts.
Each noderJS context has its own <a href="configuration.html">configuration</a> and its own cache of modules.</p>
<p>Inside the same context, when the same module is required twice, the corresponding module is in fact loaded only once and the
reference is shared.</p>
<p>However, if the same module is required from two different contexts, two different instances of the module will be loaded and
will be independent from one another.</p>
<p>It can be useful to create a new context when testing a module. The tested module can be put in a mocked environment by exposing
mocks in the new context, so that the tested module will access mocks instead of the original modules when calling the usual
<code>require</code> method.</p>
<h3 id="getting-a-context-instance">Getting a context instance</h3>
<h4 id="new-context">New context</h4>
<p>Here is how to create a new context:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> Context = <span class="built_in">require</span>(<span class="string">"noder-js/context"</span>);
<span class="keyword">var</span> contextInstance = <span class="keyword">new</span> Context({
   <span class="comment">/* context configuration */</span>
});</code></pre></div>
<p>The context configuration object is described in the <a href="configuration.html">configuration page</a>.</p>
<h4 id="current-context">Current context</h4>
<p>Here is how to get a reference to the current context:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> contextInstance = <span class="built_in">require</span>(<span class="string">"noder-js/currentContext"</span>);</code></pre></div>
<h3 id="context-instance-methods">Context instance methods</h3>
<p><strong>contextInstance.expose(path: String, object: Object)</strong></p>
<p>Exposes the given object at the given path. This means that, the next time a module with that path
has to be loaded in the context, the usual loading method will be bypassed and the given object
will be used as the export object.</p>
<p>Note that this method does not unload any already loaded module at the given path. If a module with the
given path is already loaded when this method is called, it is still accessible until it is deleted
from the cache.</p>
<p>For example:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> myObject = {};
contextInstance.expose(<span class="string">"myModule.js"</span>, myObject);

<span class="keyword">var</span> myModule = contextInstance.require(<span class="string">"myModule"</span>);
<span class="keyword">delete</span> contextInstance.require.cache[<span class="string">"myModule.js"</span>];
<span class="keyword">var</span> myReloadedModule = contextInstance.require(<span class="string">"myModule"</span>);

<span class="comment">// Here, we always have:</span>
<span class="comment">// myObject === myReloadedModule</span>

<span class="comment">// We can also have:</span>
<span class="comment">// myObject === myModule</span>
<span class="comment">// but only if myModule.js was not loaded before the call to the expose method.</span></code></pre></div>
<h3 id="context-instance-properties">Context instance properties</h3>
<p><strong>contextInstance.config</strong></p>
<p>A reference to the configuration of the context.</p>
<p><strong>contextInstance.cache</strong></p>
<p>The same object as the one available in <code>require.cache</code> from modules loaded from this context.</p>
<p><strong>contextInstance.builtinModules</strong></p>
<p>An object containing all built-in modules (also including modules exposed through the <code>expose</code> method).</p>
<p><strong>contextInstance.rootModule</strong></p>
<p>A special module created when the context is created.</p>
<h2 id="asynccall">asyncCall</h2>
<p>noder-js exposes an <code>asyncCall</code> module with some utility functions to call functions asynchronously or synchronously.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncCall = <span class="built_in">require</span>(<span class="string">"noder-js/asyncCall"</span>);</code></pre></div>
<p><strong>asyncCall.nextTick(f : function())</strong></p>
<p>Registers a function to be executed asynchronously.
The function is called with no scope and no argument.
Functions are executed in the same order as they are registered.</p>
<p>The implementation of this function in the browser version of noderJS relies on <code>setTimeout</code>.
To improve performance, multiple consecutive calls to <code>asyncCall.nextTick</code> in the same event loop turn lead to at most one call to <code>setTimeout</code>.
Calling <code>async.nextTick</code> from a function called with <code>asyncCall.nextTick</code> simply adds the new function to the list of functions to be executed,
without any call to <code>setTimeout</code>, and the function is executed at the end of the same event loop turn.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncCall = <span class="built_in">require</span>(<span class="string">"noder-js/asyncCall"</span>);
<span class="keyword">var</span> myCounter = <span class="number">0</span>;
asyncCall.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  myCounter++;
  console.log(<span class="string">"First function: "</span> + myCounter);
});
asyncCall.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  myCounter++;
  console.log(<span class="string">"Second function: "</span> + myCounter);
});
console.log(<span class="string">"Main: "</span> + myCounter);

<span class="comment">// The console will have the following output:</span>
<span class="comment">// Main: 0</span>
<span class="comment">// First function: 1</span>
<span class="comment">// Second function: 2</span></code></pre></div>
<p><strong>asyncCall.syncCall(f : function())</strong></p>
<p>Executes the given function synchronously. In case an error happens in the callback, it is thrown again asynchronously, so that the caller
of <code>asyncCall.syncCall</code> is not affected.</p>
<p>This function has the same signature as <code>asyncCall.nextTick</code>. This way, it is possible to parameterize an algorithm with a reference to a callback
executor, which can be set to be either <code>asyncCall.nextTick</code> to call callbacks asynchronously, or <code>asyncCall.syncCall</code> to call callbacks
synchronously. This is done internally for the implementation of the <code>then</code> and <code>thenSync</code> promise methods.</p>
<p><strong>asyncCall.nextTickCalls(arrayOfFunctions : Array)</strong></p>
<p>Registers an array of functions to be executed later asynchronously. The functions are called in the order in which they appear in the array.</p>
<p>Note that this function modifies the array: the first item of the array is removed, then the corresponding function is executed, then
the new first item of the array is removed, ... until there is no remaining item in the array.
Also note that, if the array is changed outside of <code>asyncCall.nextTickCalls</code> before the execution of all array items is finished, it has
an impact on the functions which are actually executed.</p>
<p><strong>asyncCall.syncCalls(arrayOfFunctions : Array)</strong></p>
<p>Synchronous version of <code>asyncCall.nextTickCalls</code>. Executes each function in the array, in order, synchronously.</p>
<p><strong>asyncCall.syncTick()</strong></p>
<p>Executes synchronously all the functions currently planned to be executed asynchronously (and registered with <code>asyncCall.nextTick</code>).
Note that this method should <strong>never</strong> be called from application code.
However, it can be useful to use it from tests to execute asynchronous code synchronously and improve performance for tests execution.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> asyncCall = <span class="built_in">require</span>(<span class="string">"noder-js/asyncCall"</span>);
<span class="keyword">var</span> methodCalled = <span class="literal">false</span>;
asyncCall.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
   methodCalled = <span class="literal">true</span>;
});
<span class="comment">// here, methodCalled = false</span>
asyncCall.syncTick(); <span class="comment">// this calls ALL the functions previously registered with asyncCall.nextTick and not yet executed</span>
<span class="comment">// here, methodCalled = true</span></code></pre></div>
<h2 id="findrequires-parser">findRequires parser</h2>
<p>noderJS includes a small parser for JavaScript code which extracts calls to the <code>require</code> method. It is exposed as <code>noder-js/findRequires</code>:</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> findRequires = <span class="built_in">require</span>(<span class="string">"noder-js/findRequires"</span>);</code></pre></div>
<p><strong>findRequires(jsCode : String, detectLoaderPlugins : Boolean)</strong></p>
<ul>
<li><code>jsCode</code>: JavaScript code to be parsed.</li>
<li><code>detectLoaderPlugins</code>: whether to return information about loader plugins.</li>
</ul>
<p><code>findRequires</code> returns an array. Each item in the array can be:</p>
<ul>
<li>a string, which is the string literal used in a call to require.</li>
<li>(only if <code>detectLoaderPlugins</code> is <code>true</code>) an object with the <code>module</code> (string), <code>method</code> (string) and <code>args</code> (array) properties, corresponding
to a call to a loader plugin.
Note that for each loader plugin detected, a string entry is also present in the array in addition to the object. Each item in the args properties
is either a string (corresponding to a string literal argument), or an array with a single string element (corresponding to a non-quoted argument
like <code>module</code> or <code>null</code>).</li>
</ul>
<p>Each string corresponds to a call to require in the source code.</p>
<div class='snippet'><pre><code class="lang-js"><span class="keyword">var</span> findRequires = <span class="built_in">require</span>(<span class="string">"noder-js/findRequires"</span>);

findRequires(<span class="string">"var myModule = require('myModule')"</span>); <span class="comment">// returns ["myModule"]</span>
findRequires(<span class="string">"var myModule = require( /* comment1 */ 'myModule' /* 'comment2' */ )"</span>); <span class="comment">// returns ["myModule"]</span>

<span class="comment">// The following 3 calls all return [] (an empty array)</span>
findRequires(<span class="string">"var myModule = require('my' + 'Module')"</span>); <span class="comment">// expressions are not included</span>
findRequires(<span class="string">"var myModule = module.require('myModule')"</span>); <span class="comment">// calls to module.require are not included</span>
findRequires(<span class="string">"var myString = \"require('myModule')\""</span>); <span class="comment">// the content of string literals is not included</span>

<span class="comment">// Loader plugins:</span>
findRequires(<span class="string">"require('$loaderPlugin').myMethod('arg1', module)"</span>); <span class="comment">// returns ['$loaderPlugin']</span>
findRequires(<span class="string">"require('$loaderPlugin').myMethod('arg1', module)"</span>, <span class="literal">true</span>);
<span class="comment">// The previous line returns:</span>
[ <span class="string">'$loaderPlugin'</span>,
  { module: <span class="string">'$loaderPlugin'</span>,
    method: <span class="string">'myMethod'</span>,
    args: [ <span class="string">'arg1'</span>, [<span class="string">"module"</span>] ] } ]</code></pre></div>
</article>
				</div>
			</div>
		</section>
	</div>
	<footer id="footer">
		<section class="content legal">
			Â© 2012 Aria Templates is licensed under Apache 2.0 license. See our <a
				href="http://ariatemplates.com/license">licensing page</a>
		</section>
	</footer>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-29575860-4', 'ariatemplates.com');
		ga('send', 'pageview');
	</script>
</body>
</html>